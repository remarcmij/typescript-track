# TypeScript Tooling

Before writing TypeScript, you need a way to run it. Browsers and Node.js run JavaScript, not TypeScript, so the type annotations must be removed before execution. There are three ways to do this, from simplest to most configurable.

## Option 1: Run TypeScript Directly in Node.js (v22.6+)

Recent versions of Node.js can run `.ts` files directly. Node.js strips the type annotations (replaces them with whitespace) and executes the remaining JavaScript. No extra packages needed.

**Node.js v23.6+ and v22.18+** — works out of the box:

```bash
node example.ts
```

**Node.js v22.6 to v22.17** — requires a flag:

```bash
node --experimental-strip-types example.ts
```

This is called **type stripping**. It is fast and zero-config, but comes with limitations:

- **No type checking** — types are stripped, not validated. You still need `tsc` to catch type errors (see Option 3).
- **Only erasable syntax** — features like `enum` and `namespace` with runtime code are not supported by default. Use `--experimental-transform-types` if you need them.
- **File extensions required in imports** — you must write `import './utils.ts'`, not `import './utils'`.
- **`.tsx` files are not supported** — this matters later when you work with React.
- **`tsconfig.json` is ignored** — Node.js does not read your TypeScript config.

Despite these limitations, this is the quickest way to start experimenting with TypeScript.

## Option 2: Use tsx (TypeScript Execute)

`tsx` is a drop-in replacement for `node` that runs TypeScript files using `esbuild` under the hood. It's faster than the traditional TypeScript compiler and supports both CommonJS and ES modules with zero configuration.

Install it:

```bash
npm install --save-dev tsx
```

Run a file:

```bash
npx tsx example.ts
```

Or use it as a drop-in for `node` (it accepts all the same flags):

```bash
npx tsx --watch example.ts
```

`tsx` is a good choice for development — running scripts, prototyping, and local dev servers. For production builds, you'll typically still use the full TypeScript compiler (Option 3) to type-check and emit JavaScript.

## Option 3: The TypeScript Compiler (tsc)

This is the standard, full-featured approach. The TypeScript compiler (`tsc`) does two independent things:

1. **Type checking** — analyses your code and reports type errors.
2. **Type removal** — strips the type annotations and emits plain JavaScript.

These two steps are independent. A file with type errors still produces runnable JavaScript — `tsc` reports the errors but emits the output anyway by default. This surprises many newcomers: type errors are warnings about correctness, not syntax errors that prevent execution. You can disable this with the `noEmitOnError` option in `tsconfig.json` if you want `tsc` to refuse to emit JavaScript when there are type errors.

### Installation

```bash
npm init -y
npm install --save-dev typescript
```

### Initialize tsconfig.json

```bash
npx tsc --init
```

This creates a `tsconfig.json` file with many options (most commented out). Here's a minimal starting point for a Node.js project:

```json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

What these options mean:

| Option            | What it does                                                                        |
| ----------------- | ----------------------------------------------------------------------------------- |
| `target`          | Which JavaScript version to output. `es2020` is a safe modern default.              |
| `module`          | Module system for the output. `commonjs` for Node.js, `esnext` for modern bundlers. |
| `outDir`          | Where compiled `.js` files go. Keeps source and output separate.                    |
| `rootDir`         | Where your `.ts` source files live.                                                 |
| `strict`          | Enables all strict type-checking options. Always use this.                          |
| `esModuleInterop` | Lets you `import express from 'express'` instead of `import * as express`.          |
| `skipLibCheck`    | Skips type-checking `.d.ts` files from `node_modules`. Speeds up compilation.       |

### Project Structure

```
my-project/
├── src/
│   └── index.ts
├── dist/           ← generated by tsc, add to .gitignore
├── tsconfig.json
└── package.json
```

### Compile and Run

```bash
npx tsc                    # compile all .ts files in src/ → dist/
node dist/index.js         # run the compiled JavaScript

npx tsc --watch            # recompile automatically on file changes
```

### Add Scripts to package.json

```json
{
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsc --watch"
  }
}
```

## Which Option Should You Use?

| Scenario                     | Recommended                                           |
| ---------------------------- | ----------------------------------------------------- |
| Quick experiments, learning  | Node.js native (`node file.ts`)                       |
| Running scripts, dev servers | `tsx`                                                 |
| Production projects, CI/CD   | `tsc` for type-checking + build                       |
| React apps                   | A framework like Vite or Next.js handles this for you |

In practice, many projects combine these: `tsx` for fast development, `tsc` for type-checking in CI, and a bundler (Vite, webpack) for the production build.

---

## What Does "Removing Types" Mean?

All three options above do the same fundamental thing: they remove type annotations so that a JavaScript engine can execute the code. The annotations are only used during development — they help your editor and the compiler catch mistakes, but they are not part of the JavaScript language.

Here's a TypeScript function:

```ts
function greet(name: string, age: number): string {
  return `Hello, ${name}. You are ${age} years old.`;
}

const message: string = greet('Aisha', 27);
```

After removing the types, you get plain JavaScript:

```js
function greet(name, age) {
  return `Hello, ${name}. You are ${age} years old.`;
}

const message = greet('Aisha', 27);
```

Every `: string` and `: number` annotation is gone. The logic is identical — the types were only there to help you write correct code.

You can see this in action in the [TypeScript Playground](https://www.typescriptlang.org/play) — paste any TypeScript on the left and the compiled JavaScript appears on the right.

How each tool handles this removal differs: `tsc` parses and type-checks first, then emits JavaScript. `tsx` uses `esbuild` to strip types at high speed without checking them. Node.js native support replaces type annotations with whitespace in-place[^1], so line numbers stay the same without needing source maps.

[^1]: This is why `node example.ts` works even though Node.js only runs JavaScript — by the time the code reaches the JavaScript engine, the types are already gone.
